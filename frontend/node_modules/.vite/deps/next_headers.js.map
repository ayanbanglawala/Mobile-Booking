{
  "version": 3,
  "sources": ["../../../../node_modules/next/dist/compiled/@edge-runtime/cookies/index.js", "../../../../node_modules/next/src/server/web/spec-extension/cookies.ts", "../../../../node_modules/next/src/server/web/spec-extension/adapters/reflect.ts", "../../../../node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts", "../../../../node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts", "../../../../node_modules/next/src/server/app-render/after-task-async-storage-instance.ts", "../../../../node_modules/next/src/server/app-render/after-task-async-storage.external.ts", "../../../../node_modules/next/src/server/request/utils.ts", "../../../../node_modules/next/src/server/request/cookies.ts", "../../../../node_modules/next/src/server/web/spec-extension/adapters/headers.ts", "../../../../node_modules/next/src/server/request/headers.ts", "../../../../node_modules/next/src/server/request/draft-mode.ts", "../../../../node_modules/next/headers.js"],
  "sourcesContent": ["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  RequestCookies: () => RequestCookies,\n  ResponseCookies: () => ResponseCookies,\n  parseCookie: () => parseCookie,\n  parseSetCookie: () => parseSetCookie,\n  stringifyCookie: () => stringifyCookie\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/serialize.ts\nfunction stringifyCookie(c) {\n  var _a;\n  const attrs = [\n    \"path\" in c && c.path && `Path=${c.path}`,\n    \"expires\" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === \"number\" ? new Date(c.expires) : c.expires).toUTCString()}`,\n    \"maxAge\" in c && typeof c.maxAge === \"number\" && `Max-Age=${c.maxAge}`,\n    \"domain\" in c && c.domain && `Domain=${c.domain}`,\n    \"secure\" in c && c.secure && \"Secure\",\n    \"httpOnly\" in c && c.httpOnly && \"HttpOnly\",\n    \"sameSite\" in c && c.sameSite && `SameSite=${c.sameSite}`,\n    \"partitioned\" in c && c.partitioned && \"Partitioned\",\n    \"priority\" in c && c.priority && `Priority=${c.priority}`\n  ].filter(Boolean);\n  const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : \"\")}`;\n  return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(\"; \")}`;\n}\nfunction parseCookie(cookie) {\n  const map = /* @__PURE__ */ new Map();\n  for (const pair of cookie.split(/; */)) {\n    if (!pair)\n      continue;\n    const splitAt = pair.indexOf(\"=\");\n    if (splitAt === -1) {\n      map.set(pair, \"true\");\n      continue;\n    }\n    const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];\n    try {\n      map.set(key, decodeURIComponent(value != null ? value : \"true\"));\n    } catch {\n    }\n  }\n  return map;\n}\nfunction parseSetCookie(setCookie) {\n  if (!setCookie) {\n    return void 0;\n  }\n  const [[name, value], ...attributes] = parseCookie(setCookie);\n  const {\n    domain,\n    expires,\n    httponly,\n    maxage,\n    path,\n    samesite,\n    secure,\n    partitioned,\n    priority\n  } = Object.fromEntries(\n    attributes.map(([key, value2]) => [\n      key.toLowerCase().replace(/-/g, \"\"),\n      value2\n    ])\n  );\n  const cookie = {\n    name,\n    value: decodeURIComponent(value),\n    domain,\n    ...expires && { expires: new Date(expires) },\n    ...httponly && { httpOnly: true },\n    ...typeof maxage === \"string\" && { maxAge: Number(maxage) },\n    path,\n    ...samesite && { sameSite: parseSameSite(samesite) },\n    ...secure && { secure: true },\n    ...priority && { priority: parsePriority(priority) },\n    ...partitioned && { partitioned: true }\n  };\n  return compact(cookie);\n}\nfunction compact(t) {\n  const newT = {};\n  for (const key in t) {\n    if (t[key]) {\n      newT[key] = t[key];\n    }\n  }\n  return newT;\n}\nvar SAME_SITE = [\"strict\", \"lax\", \"none\"];\nfunction parseSameSite(string) {\n  string = string.toLowerCase();\n  return SAME_SITE.includes(string) ? string : void 0;\n}\nvar PRIORITY = [\"low\", \"medium\", \"high\"];\nfunction parsePriority(string) {\n  string = string.toLowerCase();\n  return PRIORITY.includes(string) ? string : void 0;\n}\nfunction splitCookiesString(cookiesString) {\n  if (!cookiesString)\n    return [];\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\n// src/request-cookies.ts\nvar RequestCookies = class {\n  constructor(requestHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    this._headers = requestHeaders;\n    const header = requestHeaders.get(\"cookie\");\n    if (header) {\n      const parsed = parseCookie(header);\n      for (const [name, value] of parsed) {\n        this._parsed.set(name, { name, value });\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this._parsed[Symbol.iterator]();\n  }\n  /**\n   * The amount of cookies received from the client\n   */\n  get size() {\n    return this._parsed.size;\n  }\n  get(...args) {\n    const name = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(name);\n  }\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed);\n    if (!args.length) {\n      return all.map(([_, value]) => value);\n    }\n    const name = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter(([n]) => n === name).map(([_, value]) => value);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  set(...args) {\n    const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;\n    const map = this._parsed;\n    map.set(name, { name, value });\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join(\"; \")\n    );\n    return this;\n  }\n  /**\n   * Delete the cookies matching the passed name or names in the request.\n   */\n  delete(names) {\n    const map = this._parsed;\n    const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value]) => stringifyCookie(value)).join(\"; \")\n    );\n    return result;\n  }\n  /**\n   * Delete all the cookies in the cookies in the request.\n   */\n  clear() {\n    this.delete(Array.from(this._parsed.keys()));\n    return this;\n  }\n  /**\n   * Format the cookies in the request as a string for logging\n   */\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join(\"; \");\n  }\n};\n\n// src/response-cookies.ts\nvar ResponseCookies = class {\n  constructor(responseHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    var _a, _b, _c;\n    this._headers = responseHeaders;\n    const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(\"set-cookie\")) != null ? _c : [];\n    const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);\n    for (const cookieString of cookieStrings) {\n      const parsed = parseSetCookie(cookieString);\n      if (parsed)\n        this._parsed.set(parsed.name, parsed);\n    }\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.\n   */\n  get(...args) {\n    const key = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(key);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.\n   */\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed.values());\n    if (!args.length) {\n      return all;\n    }\n    const key = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter((c) => c.name === key);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.\n   */\n  set(...args) {\n    const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;\n    const map = this._parsed;\n    map.set(name, normalizeCookie({ name, value, ...cookie }));\n    replace(map, this._headers);\n    return this;\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.\n   */\n  delete(...args) {\n    const [name, options] = typeof args[0] === \"string\" ? [args[0]] : [args[0].name, args[0]];\n    return this.set({ ...options, name, value: \"\", expires: /* @__PURE__ */ new Date(0) });\n  }\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map(stringifyCookie).join(\"; \");\n  }\n};\nfunction replace(bag, headers) {\n  headers.delete(\"set-cookie\");\n  for (const [, value] of bag) {\n    const serialized = stringifyCookie(value);\n    headers.append(\"set-cookie\", serialized);\n  }\n}\nfunction normalizeCookie(cookie = { name: \"\", value: \"\" }) {\n  if (typeof cookie.expires === \"number\") {\n    cookie.expires = new Date(cookie.expires);\n  }\n  if (cookie.maxAge) {\n    cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);\n  }\n  if (cookie.path === null || cookie.path === void 0) {\n    cookie.path = \"/\";\n  }\n  return cookie;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  RequestCookies,\n  ResponseCookies,\n  parseCookie,\n  parseSetCookie,\n  stringifyCookie\n});\n", "export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n", "export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n", "import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport {\n  getExpectedRequestStore,\n  type RequestStore,\n} from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function wrapWithMutableAccessCheck(\n  responseCookies: ResponseCookies\n): ResponseCookies {\n  const wrappedCookies = new Proxy(responseCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable('cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable('cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(callingExpression: string) {\n  const requestStore = getExpectedRequestStore(callingExpression)\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n", "import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n", "import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n", "import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n", "import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(route: string): never {\n  throw new Error(\n    `Route ${route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n", "import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the cookies object.\n        return makeDynamicallyTrackedExoticCookies(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how cookies has worked in PPR without dynamicIO.\n        postponeWithTracking(\n          workStore.route,\n          callingExpression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We track dynamic access here so we don't need to wrap the cookies in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration(\n          callingExpression,\n          workStore,\n          workUnitStore\n        )\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  if (areCookiesMutableInCurrentPhase(requestStore)) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeDynamicallyTrackedExoticCookies(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`cookies()[Symbol.iterator]()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    size: {\n      get() {\n        const expression = '`cookies().size`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = new Promise<ReadonlyRequestCookies>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingCookies))\n  )\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...cookies()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = '`cookies().size`'\n        syncIODev(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        syncIODev(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()` or implicit casting'\n        syncIODev(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n", "import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n", "import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedHeaders = ReadonlyHeaders\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedExoticHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the headers object.\n        return makeDynamicallyTrackedExoticHeaders(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how headers has worked in PPR without dynamicIO.\n        // TODO consider switching the semantic to throw on property access instead\n        postponeWithTracking(\n          workStore.route,\n          'headers',\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We are in a legacy static generation mode while prerendering\n        // We track dynamic access here so we don't need to wrap the headers in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration('headers', workStore, workUnitStore)\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  const requestStore = getExpectedRequestStore('headers')\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticHeadersWithDevWarnings(\n      requestStore.headers,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticHeaders(requestStore.headers)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeDynamicallyTrackedExoticHeaders(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`headers()[Symbol.iterator]()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: underlyingHeaders.append.bind(underlyingHeaders),\n    },\n    delete: {\n      value: underlyingHeaders.delete.bind(underlyingHeaders),\n    },\n    get: {\n      value: underlyingHeaders.get.bind(underlyingHeaders),\n    },\n    has: {\n      value: underlyingHeaders.has.bind(underlyingHeaders),\n    },\n    set: {\n      value: underlyingHeaders.set.bind(underlyingHeaders),\n    },\n    getSetCookie: {\n      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n    },\n    forEach: {\n      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n    },\n    keys: {\n      value: underlyingHeaders.keys.bind(underlyingHeaders),\n    },\n    values: {\n      value: underlyingHeaders.values.bind(underlyingHeaders),\n    },\n    entries: {\n      value: underlyingHeaders.entries.bind(underlyingHeaders),\n    },\n    [Symbol.iterator]: {\n      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = new Promise<ReadonlyHeaders>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingHeaders))\n  )\n\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.append.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.delete.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.getSetCookie.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        syncIODev(route, expression)\n        return underlyingHeaders.forEach.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.values.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.entries.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...headers()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingHeaders[Symbol.iterator].apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'string' ? `'${arg}'` : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\ntype HeadersExtensions = {\n  [K in keyof ReadonlyHeaders]: unknown\n}\n", "import { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\n\n/**\n * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedDraftMode = DraftMode\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache' ||\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      // Return empty draft mode\n      if (\n        process.env.NODE_ENV === 'development' &&\n        !workStore?.isPrefetchRequest\n      ) {\n        const route = workStore?.route\n        return createExoticDraftModeWithDevWarnings(null, route)\n      } else {\n        return createExoticDraftMode(null)\n      }\n    }\n  }\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  const cachedDraftMode = CachedDraftModes.get(requestStore.draftMode)\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  let promise\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    promise = createExoticDraftModeWithDevWarnings(\n      requestStore.draftMode,\n      route\n    )\n  } else {\n    promise = createExoticDraftMode(requestStore.draftMode)\n  }\n  CachedDraftModes.set(requestStore.draftMode, promise)\n  return promise\n}\n\ninterface CacheLifetime {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createExoticDraftMode(\n  underlyingProvider: null | DraftModeProvider\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n  ;(promise as any).enable = instance.enable.bind(instance)\n  ;(promise as any).disable = instance.disable.bind(instance)\n\n  return promise\n}\n\nfunction createExoticDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      const expression = '`draftMode().isEnabled`'\n      syncIODev(route, expression)\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n\n  Object.defineProperty(promise, 'enable', {\n    value: function get() {\n      const expression = '`draftMode().enable()`'\n      syncIODev(route, expression)\n      return instance.enable.apply(instance, arguments as any)\n    },\n  })\n\n  Object.defineProperty(promise, 'disable', {\n    value: function get() {\n      const expression = '`draftMode().disable()`'\n      syncIODev(route, expression)\n      return instance.disable.apply(instance, arguments as any)\n    },\n  })\n\n  return promise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()')\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()')\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string) {\n  const store = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (store) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n        )\n      }\n    }\n\n    if (store.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        const error = new Error(\n          `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n        )\n        abortAndThrowOnSynchronousRequestDataAccess(\n          store.route,\n          expression,\n          error,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender\n        postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // legacy Prerender\n        workUnitStore.revalidate = 0\n\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      } else if (\n        process.env.NODE_ENV === 'development' &&\n        workUnitStore &&\n        workUnitStore.type === 'request'\n      ) {\n        workUnitStore.usedDynamic = true\n      }\n    }\n  }\n}\n", "module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n"],
  "mappings": "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",
  "names": ["RequestCookies", "ResponseCookies", "stringifyCookie", "ReflectAdapter", "get", "target", "prop", "receiver", "value", "Reflect", "bind", "set", "has", "deleteProperty", "MutableRequestCookiesAdapter", "ReadonlyRequestCookiesError", "RequestCookiesAdapter", "appendMutableCookies", "areCookiesMutableInCurrentPhase", "getModifiedCookieValues", "responseCookiesToRequestCookies", "wrapWithMutableAccessCheck", "Error", "constructor", "callable", "seal", "cookies", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "SYMBOL_MODIFY_COOKIE_VALUES", "Symbol", "for", "modified", "Array", "isArray", "length", "headers", "mutableCookies", "modifiedCookieValues", "resCookies", "ResponseCookies", "returnedCookies", "getAll", "cookie", "set", "wrap", "onUpdateCookies", "responseCookies", "Headers", "modifiedValues", "modifiedCookies", "Set", "updateResponseCookies", "workStore", "workAsyncStorage", "getStore", "pathWasRevalidated", "allCookies", "filter", "c", "has", "name", "serializedCookies", "tempCookies", "push", "toString", "wrappedCookies", "args", "add", "delete", "ensureCookiesAreStillMutable", "requestStore", "phase", "callingExpression", "getExpectedRequestStore", "requestCookies", "RequestCookies", "createDedupedByCallsiteServerErrorLoggerDev", "errorRef", "current", "cache", "React", "fn", "logErrorOrWarn", "process", "env", "__NEXT_DYNAMIC_IO", "console", "error", "warn", "flushCurrentErrorIfNew", "key", "getMessage", "logDedupedError", "args", "message", "callStackFrames", "Error", "stack", "split", "undefined", "length", "afterTaskAsyncStorageInstance", "createAsyncLocalStorage", "afterTaskAsyncStorage", "isRequestAPICallableInsideAfter", "throwForSearchParamsAccessInUseCache", "throwWithStaticGenerationBailoutError", "throwWithStaticGenerationBailoutErrorWithDynamicError", "route", "expression", "StaticGenBailoutError", "Error", "afterTaskStore", "afterTaskAsyncStorage", "getStore", "rootTaskSpawnPhase", "cookies", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingCookies", "createEmptyCookies", "makeUntrackedExoticCookies", "type", "dynamicShouldError", "StaticGenBailoutError", "makeDynamicallyTrackedExoticCookies", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "trackDynamicDataInDynamicRender", "requestStore", "getExpectedRequestStore", "areCookiesMutableInCurrentPhase", "userspaceMutableCookies", "isPrefetchRequest", "makeUntrackedExoticCookiesWithDevWarnings", "RequestCookiesAdapter", "seal", "RequestCookies", "Headers", "CachedCookies", "WeakMap", "prerenderStore", "cachedPromise", "get", "promise", "makeHangingPromise", "renderSignal", "set", "Object", "defineProperties", "Symbol", "iterator", "value", "expression", "error", "createCookiesAccessError", "abortAndThrowOnSynchronousRequestDataAccess", "size", "arguments", "length", "describeNameArg", "getAll", "has", "arg", "delete", "clear", "toString", "cachedCookies", "Promise", "resolve", "bind", "polyfilledResponseCookiesIterator", "polyfilledResponseCookiesClear", "scheduleImmediate", "syncIODev", "apply", "call", "writable", "name", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "createDedupedByCallsiteServerErrorLoggerDev", "prefix", "map", "c", "values", "returnable", "cookie", "HeadersAdapter", "ReadonlyHeadersError", "Error", "constructor", "callable", "Headers", "headers", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "lowercased", "toLowerCase", "original", "Object", "keys", "find", "o", "set", "value", "has", "deleteProperty", "seal", "merge", "Array", "isArray", "join", "from", "append", "name", "existing", "push", "delete", "forEach", "callbackfn", "thisArg", "entries", "call", "key", "values", "Symbol", "iterator", "headers", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingHeaders", "HeadersAdapter", "seal", "Headers", "makeUntrackedExoticHeaders", "type", "dynamicShouldError", "StaticGenBailoutError", "makeDynamicallyTrackedExoticHeaders", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "trackDynamicDataInDynamicRender", "requestStore", "getExpectedRequestStore", "isPrefetchRequest", "makeUntrackedExoticHeadersWithDevWarnings", "CachedHeaders", "WeakMap", "prerenderStore", "cachedHeaders", "get", "promise", "makeHangingPromise", "renderSignal", "set", "Object", "defineProperties", "append", "value", "expression", "describeNameArg", "arguments", "error", "createHeadersAccessError", "abortAndThrowOnSynchronousRequestDataAccess", "delete", "_delete", "has", "getSetCookie", "forEach", "keys", "values", "entries", "Symbol", "iterator", "Promise", "resolve", "bind", "scheduleImmediate", "syncIODev", "apply", "arg", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "createDedupedByCallsiteServerErrorLoggerDev", "prefix", "draftMode", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "type", "isPrefetchRequest", "route", "createExoticDraftModeWithDevWarnings", "createExoticDraftMode", "requestStore", "getExpectedRequestStore", "cachedDraftMode", "CachedDraftModes", "get", "promise", "set", "WeakMap", "underlyingProvider", "instance", "DraftMode", "Promise", "resolve", "Object", "defineProperty", "isEnabled", "newValue", "value", "writable", "enumerable", "configurable", "enable", "bind", "disable", "expression", "syncIODev", "apply", "arguments", "constructor", "provider", "_provider", "trackDynamicDraftMode", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "createDedupedByCallsiteServerErrorLoggerDev", "createDraftModeAccessError", "prefix", "Error", "store", "phase", "dynamicShouldError", "StaticGenBailoutError", "error", "abortAndThrowOnSynchronousRequestDataAccess", "postponeWithTracking", "dynamicTracking", "revalidate", "err", "DynamicServerError", "dynamicUsageDescription", "dynamicUsageStack", "stack", "usedDynamic", "require_headers"]
}
